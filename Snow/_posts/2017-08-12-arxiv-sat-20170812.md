---
layout: post
category: Deep Learning, Research
title: شنبه‌های آرکایو (دوشنبه ۱۶ مرداد - شنبه ۲۱ مرداد)
---
به نام خدا
===========

در مورد شنبه‌های آرکایو
[قبلاً](https://github.com/n1analytics/python-paillier/blob/master/phe/paillier.py#L746-L748)
نوشتم. این بار تصمیم گرفتم که برای هر هفته پستی بنویسم و مقالات جالبی رو که پیدا کردم معرفی کنم.
فعلاً این هفته به صورت آزمایشی این کار رو انجام میدم تا بعد تصمیم بگیرم که آیا ادامه خواهم داد یا نه.

این هفته ۴۷۲ عنوان جدید تو قسمت‌های منتخب آرکایو بارگزاری شده که البته این، عدد، تعداد مقالات یکتا نیست.
تعداد مقالات یکتا شاید نصف این عدد باشه.
دلیلش اینه که بعضی از مقالات ممکنه که در بیش از یک موضوع دسته‌بندی شده باشن.
این بار cs.CV (طبق معمول) بیشترین مقاله‌ی جدید رو با ۱۴۲ عنوان جدید داشت.

قسمت‌هایی که من دنبال می‌کنم این قسمت‌ها هستن:

* cs.{AI, CG, CL, CV, IR, LG, NE, RO}
* stat.ML

## مقالات منتخب هفته‌ی گذشته

**"Regularizing and Optimizing LSTM Language Models"** - [1708.02182](https://arxiv.org/abs/1708.02182)

Stephen Merity, Nitish Shirish Keskar, Richard Socher

Salesforce Research

در این مقاله مسئله‌ی آموزش مدل‌های زبانی سطح کلمه (word-level) مورد توجه قرار گرفته و روش‌های مختلف بهینه‌سازی و تنظیم (regularization) مدل‌های مبتنی بر LSTM بررسی شدن.

از طریق این روش‌های بهبود یافته‌ی آموزش مدل‌های زبانی مبتنی بر LSTM، در این مقاله تونستن به بهترین نتیجه روی دو دیتاست Penn Tree Bank و WikiText-2 دست پیدا کنن.

یکی از این روش‌ها، استفاده از DropConnect با ماسک ثابت در راستای زمان، برای اتصالات پنهان-به-پنهان در فرمول‌بندی LSTM هست.
تفاوت DropConnect با Dropout در این هست که در Dropout ماسک تصادفی بر روی خروجی یک لایه اعمال میشه تا لایه‌ی بعد به عنوان ورودی، نسخه‌ای مخدوش‌شده از خروجی لایه‌ی قبل رو بگیره.
در مقابل در DropConnect این ماسک تصادفی بر روی وزن‌های یک لایه‌ی fully-connected اعمال میشه.

برای بقیه‌ی اتصالات در این کار از Dropout معمولی استفاده شده، ولی ماسک تصادفی یک بار نمونه‌گیری شده و در طول دنباله از این ماسک استفاده شده، یعنی در واقع Variational Dropout.
کار دیگه‌ای هم که در این مقاله انجام شده استفاده از Dropout بر روی ماتریس Embedding هست، به این شکل که در هر بار نمونه‌گیری از ماسک تصادفی ممکنه تعدادی از کلمات حذف بشن.
طبق معمول یه سری کارهای قبلی در زمینه‌ی یادگیری مدل زبانی و ترجمه‌ی ماشینی، در این کار وزن‌های ماتریس Embedding و لایه‌ی خروجی (یا لایه‌ی softmax) مشترک هستن.
این کار هم باعث میشه که تعداد پارامترهای مدل کم بشه و هم اینکه یک شهود نظری پشت این کار هست [1].

یک regularization جالب دیگه‌ای که انجام دادن
Activation Regularization و
Temporal Activation Regularization هست که تقریباً جدید هستن و تو کارهای زیادی قبلاً ندیدم.
توی Activation Regularization هدف اینه که خروجی میانی LSTM مقادیر کوچکی بگیرن،‌ یعنی

$$ \alpha L _ 2 (m \odot h _ t) $$.
در مقابل در Temporal Activation Regularization
هدف اینه که خروجی‌های میانی LSTM در طول زمان خیلی متغیر نباشن، یعنی

$$ \beta L _ 2 (h _ t - h _ {t+1}) $$

در کل به نظر میاد که مقاله‌ی خوبی باشه و بشه به نتایج‌شون اعتماد کرد، هر چند تا جایی که می‌دونم کد مقاله رو منتشر نکردن.
اگر می‌خوایید از LSTM برای پردازش دنباله استفاده کنید، بخصوص برای مدل‌های زمانی، خوندن این مقاله فکر می‌کنم مفید می‌تونه باشه.

[1]: https://arxiv.org/abs/1611.01462

**"Recent Trends in Deep Learning Based Natural Language Processing"** - [1708.02709](https://arxiv.org/abs/1708.02709)

Tom Young, Devamanyu Hazarika, Soujanya Poria, Erik Cambria

School of Information and Electronics, Beijing Institute of Technology, China; School of Computing, National University of Singapore, Singapore; Temasek Laboratories, Nanyang Technological University, Singapore; School of Computer Science and Engineering, Nanyang Technological University, Singapore

این مقاله به طور کلی به بررسی پیشینه، وضعیت فعلی، و روند پیشرفت روش‌های مبتنی بر شبکه‌های عصبی برای پردازش زبان‌های طبیعی پرداخته. اگر تازه می‌خوایید وارد این موضوع بشید یا حتی اگر می‌خوایید با تاریخچه و روال فعلی این موضوعات آشنا بشید این مقاله منبع خوبیه برای مطالعه‌ی اولیه.

**"Revisiting Unreasonable Effectiveness of Data in Deep Learning Era"** - [1707.02968](https://arxiv.org/abs/1707.02968)

Chen Sun, Abhinav Shrivastava, Saurabh Singh, Abhinav Gupta

Google Research, Carnegie Mellon University

تا مدتی قبل بزرگ‌ترین مجموعه دادگان در دسترس عموم برای کلاسه‌بندی تصاویر مجموعه دادگان ImageNet بود.
ولی شرکت‌های بزرگ هر کدوم مجموعه دادگان خیلی بزرگ‌تری داشتن.
یکی از این مجموعه دادگان که مال گوگل هست JFT نام داره و حاوی بیش از ۳۰۰ میلیون(!) تصویر با ۱۸۲۹۱ دسته هست. البته برچسب‌زنی این همه تصویر به صورت خودکار انجام شده و بنابراین دارای خطا هستن. ولی با این حال اندازه‌ی این مجموعه دادگان واقعاً بزرگه.
توی این مقاله گوگلی‌ها بررسی کردن که آیا معماری‌های معمول دسته‌بندی تصاویر وقتی که تعداد تصاویر به مقدار قابل توجهی زیاد بشه باز هم می‌تونن به نتیجه‌ی بهتری دست پیدا بکنن و نمایش بهتری از داده‌ها رو یاد بگیرن؟
برای این کار یک مدل ResNet-101 رو روی این مجموعه دادگان آموزش میدن (در مورد جزئیات این آموزش توی مقاله نوشته شده) و بعد از این مدل آموزش دیده شده به عنوان مدل اولیه برای چهار downstream task دیگه استفاده می‌کنن، یعنی کلاسه‌بندی تصاویر، تشخیص اشیا، قطعه‌بندی معنایی تصاویر، و تشخیص وضعیت (اسکلت) انسان.
اونطوری که حدس زدن نتیجه‌ی این کار دور از انتظار نیست، مدل آموزش داده شده بر روی مجموعه تصاویر JFT-300M و بعد fine-tune شده روی هر مجموعه دادگان تونسته بهترین نتیجه رو توی هر کدوم از این چالش‌ها به دست بیاره.

چون کسی به غیر از گوگل به مجموعه دادگان به این بزرگی دسترسی نداره، تنها میشه امیدوار شد که گوگل مدل آموزش‌داده‌شده بر روی این مجموعه دادگان بزرگ رو منتشر بکنه (تا الان که این کار رو نکرده، بعید می‌دونم بعد از این هم بکنه).

**"Tips and Tricks for Visual Question Answering: Learnings from the 2017 Challenge"** - [1708.02711](https://arxiv.org/abs/1708.02711)

Damien Teney, Peter Anderson, Xiaodong He, Anton van den Hengel

Australian Centre for Visual Technologies, The University of Adelaide, Australia; Australian National University, Canberra, Australia; Deep Learning Technology Center, Microsoft Research, Redmond, WA, USA


این مقاله شرح روشی هست که در آخرین مسابقه‌ی پاسخ پرسش‌های تصویری VQA 2017 که بر روی نسخه‌ی دوم مجموعه دادگان VQA هم بود تونست مقام اول رو کسب بکنه.
تقریباً میشه با نگاهی به تصویر دوم در مقاله کلیت روش رو فهمید. نکات جالب این مدل به نظرم در مقایسه با مدل‌های دیگه برای VQA یکی روش استخراج ویژگی‌های تصویر هست که از R-CNN استفاده شده، و نکته‌ی بعدی هم استفاده از ضرب درایه به درایه برای ترکیب ویژگی‌های سوال و تصویر هست.
این کار تقریباً بر خلاف اکثر کارهای اخیر هست که توی اون‌ها تعامل‌های مرتبه بالاتری بین توصیف تصویر و سوال مدل‌سازی میشن، مثلاً انواع تعامل bilinear به جای ضرب هادامارد ساده. ولی خب در اینجا تونستن
البته کار جدیدی که توی این مدل انجام دادن و به خاطر ندارم مدل‌های دیگه‌ای این کار رو کرده باشن اینه که مسئله‌ی VQA رو (با در نظر گرفتن برچسب‌های این دیتاست) تبدیل کردن به یه مسئله‌ی دسته‌بندی چند برچسبی (Multi-label classification).
یه نکته‌ی خیلی عجیب در مورد این مقاله این هست که این شبکه با استفاده از MATLAB پیاده‌سازی و آموزش داده شده.

چیزی که باعث شد من خیلی از این مقاله خوشم بیاد، علاوه بر اینکه قسمت‌های مختلف کارشون رو خوب توضیح دادن، اینه که Ablation study خیلی مفصلی انجام دادن که دقیقاً تشریح می‌کنه هر قسمت از مدل‌شون و هر کاری که انجام دادن چقدر در رسیدن به نتیجه‌ی نهایی تاثیر داشته.
همین کار باعث میشه که اعتماد آدم به این کار و نتایجش تقریباً تضمین بشه. ولی اینکه کد این مقاله منتشر نشده و البته اگر هم منتشر بشه با MATLAB نوشته شده یکی از نکات منفی این کار هست، البته در مقابل نکات قوت این کار میشه کاملاً ازشون چشم‌پوشی کرد.

فکر می‌کنم از این به بعد اگر کسی بخواد روی مسئله‌ی VQA کار بکنه باید از این کار شروع بکنه.

**"MemexQA: Visual Memex Question Answering"** - [1708.01336](https://arxiv.org/abs/1708.01336)

Lu Jiang, Junwei Liang, Liangliang Cao, Yannis Kalantidis, Sachin Farfade, Alexander Hauptmann

Carnegie Mellon University, Customer Service AI, Yahoo Research

این مقاله کار بسیار جالبی هست که توجه من رو خیلی جلب کرد و فکر می‌کنم چیزی هست که در آینده‌ی نزدیک خیلی دوست دارم روش کار بکنم.
این مقاله مسئله‌ی MemexQA رو معرفی می‌کنه.
این مسئله اینطوری تعریف میشه که اگر یک مجموعه از تصاویر و ویدیوها متعلق به یک فردی داده بشن، هدف اینه که به صورت خودکار به سوالات کاربر جواب بدیم تا کاربر بتونه خاطراتش رو در مورد رویدادهایی که اتفاق افتادن و توی اون مجموعه به تصویر کشیده شدن به خاطر بیاره.
مثلاً یه سری تصویر از یک جشن تولد دارید ولی به خاطر نمیارید که جشن تولد کی بوده.
هدف این کار اینه که این سیستم بتونه به این سوال که جشن تولد کی بوده پاسخ بده و برای پاسخش هم تعدادی تصاویر از اون مجموعه تصاویر به عنوان مدرک بیاره.
برای اینکار یک مجموعه دادگان جدید هم به همین اسم منتشر شده، البته در حال حاضر در دسترس نیست، ولی به زودی خواهد بود.
این مسئله و کلیت مقاله به نظرم خیلی جالب هستن و البته مدل اولیه‌ای که ارائه دادن خیلی مدل پیچیده‌ای نیست. بنابراین فکر می‌کنم میشه با مدل بهتری نتایج بهتری روی این مجموعه دادگان گرفت. در کل اگر به مسئله‌ی مطرح شده تو این مقاله علاقه دارید حتماً مقاله رو کامل بخونید.

**"TensorFlow Estimators: Managing Simplicity vs. Flexibility in High-Level Machine Learning Frameworks"** - [1708.02637](https://arxiv.org/abs/1708.02637)

Heng-Tze Cheng, Zakaria Haque, Lichan Hong, Mustafa Ispir, Clemens Mewald, Illia Polosukhin, Georgios Roumpos, D Sculley, Jamie Smith, David Soergel, Yuan Tang, Philipp Tucker, Martin Wicke, Cassandra Xia, Jianwei Xie

Google; UptakeTechnologies

این یک مقاله‌ی خیلی جالبی هست که توی کنفرانس KDD 2017 پذیرفته شده و رابط برنامه‌نویسی `Estimator` رو در کتابخانه‌ی TensorFlow معرفی می‌کنه.
ساختاردهی و مدیریت کد یکی از کارهای سختیه که نیاز به تجربه‌ی زیادی داره.
ولی با این حال بعضی وقت‌ها کتابخانه‌ها می‌تونن با فراهم کردن رابط‌های برنامه‌نویسی خوب ساختاردهی مناسبی به کد کاربر اعمال بکنن.
یکی از این ساختاردهی‌ها توی کتابخانه‌ی TensorFlow با استفاده از کلاس `Estimator` اعمال میشه که در این مقاله به طور مفصلی در این مورد صحبت کرده.
از روی تجربه‌ام فکر می‌کنم دنبال کردن یک ساختار برنامه‌نویسی که سطح بالا است و در عین حال انعطاف‌پذیری کافی هم داره هم باعث میشه که پروژه سریع‌تر جلو بره و هم با گذشت زمان هم‌چنان کد قابل مدیریت باقی می‌مونه. حدود شش ماه پیش که تصمیم گرفتم آخرین پروژه‌ام رو با استفاده از کتابخانه‌ی TensorFlow شروع کردم خوشبختانه با نمونه کدی شروع کردم که از این رابط‌های برنامه‌نویسی مثل کلاس `Estimator` استفاده می‌کرد.
هر چند استفاده از این رابط‌ها هنوز معمول نیست بین برنامه‌نویس‌ها، ولی از این انتخاب بسیار راضی هستم. چون باعث شده که با وجود نیاز به تغییرات بنیادین و البته بزرگ‌شدن زیاد کد در طول پروژه، نیازی نباشه که کل کد رو چند بار از اول ساختاردهی بکنم و دوباره بنویسم و یا اینکه مشکلات بزرگی در کد پیش بیاد.

اگر می‌خوایید پروژه‌ای با اندازه‌ی متوسط به بالا با کتابخانه‌ی TensorFlow پیاده‌سازی بکنید پیشنهاد می‌کنم از رابط‌های برنامه‌نویسی کلاس‌های `Estimator` و `Experiment` استفاده کنید و این مقاله رو هم بخونید.


## پست‌های وبلاگ منتخب از هفته‌ی گذشته
[تولدستیزی مصنوعی خیرخواهانه!](https://www.edge.org/conversation/thomas_metzinger-benevolent-artificial-anti-natalism-baan)

این یه مطلب تقریباً مفصل هست در مورد یک سناریوی غیرمحتمل که البته بیشتر جنبه‌ی فکری داره، تا اینکه واقعاً امکانش وجود داشته باشه. به نوعی یک آزمایش ذهنی.

فرض کنید یک ابرهوش به وجود بیاد که توانایی ذهنی بسیار زیادی داره، خیلی بیشتر از توانایی ذهنی انسان‌ها.
بنابراین میشه نتیجه گرفت که این موجودیت توانایی بیشتری هم در زمینه‌ی استدلال در مورد اخلاق و آداب هم داره.
حالا فرض کنید که این موجودیت به انسان‌ها و زندگی کردن‌شون رو ببینه و بعد به این نتیجه برسه که اگر انسان‌ها به دنیا نیان، بنابراین نمی‌تونن رنجی رو هم متحمل بشن.
بنابراین خیلی خیرخواهانه تصمیم می‌گیره که سیاست تولدستیزی (Anti-Natalism) سیاست خیلی خوبی در مورد انسان‌هاست.
